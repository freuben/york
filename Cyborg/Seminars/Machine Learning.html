<html><head><title>Machine Learning</title>
<link rel='stylesheet' href='./../../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../../scdoc.js' type='text/javascript'></script>
<script src='./../../docmap.js' type='text/javascript'></script>
<script src='./../../prettify.js' type='text/javascript'></script>
<script src='./../../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./../..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider CYBORG/SEMINARS (extension)</div>
<div id='categories'><a href='./../../Browse.html#Tutorials/Cyborg'>Tutorials/Cyborg</a></div>
<h1>Machine Learning</h1>
<div id='summary'>Cyborg Music</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../../Cyborg.html">Cyborg Music</a>, <a href="./../../Cyborg/Seminars/Computational Creativity and Music 2.html">Computational Creativity and Music 2</a></div>
</div>
<div id='toc'>
<ul class='toc'></ul></div><div class='image'><img src='http://www.squib-box.com/fr/computerdotplay/seminars/seminar4/seminar 4.036.png'/></div>
<pre class='code prettyprint lang-sc'>Quarks.gui //install NatureToolKit

//NatureToolKit includes classes like:
ModernLife //Cellular Automata
LSys //L-systems
GAWorkbench //Genetic Algorithms</pre>

<p><div class='image'><img src='http://www.squib-box.com/fr/computerdotplay/seminars/seminar4/seminar 4.037.png'/><br><b>Cellular Automata - emanueleferonato.com</b></div>
<div class='image'><img src='http://www.squib-box.com/fr/computerdotplay/seminars/seminar4/seminar 4.038.png'/></div>

<p><pre class='code prettyprint lang-sc'>ModernLife
// the default rule is "23/3" (Conway's Game of Life)
a = ModernLife.new; //will pop up the window
//press space to run/stop. c to clear, r to randomize.
//you can also create or kill cells with mouse interaction.

a = ModernLife.new(8, 500); //numDivs, winSize (pixels)
a.userFunc_({|states, population| states.postcs; population.postln; });
//press space

// conway's gol by default
a = ModernLife.new.play;
a.stop;</pre>

<p><strong>setRule (argRuleString)</strong>
<p>Sets the rule for the CA system. The notation for the rule is the same used in Mirek's Cellebration. It is a string in the format x/y where x and y are sequence of unique digits between 0 and 8 (inclusive). The digits in x side (for example digit d) means that a live cell with d live neighbors will survive to the next generation (others will die), and a digits in y side (digit k as an example) means that any dead cell with k alive neighbors will come to life. With this scheme, the Conway's Game of Life is defined as "23/3" (which is the default rule).<pre class='code prettyprint lang-sc'>//maze
a = ModernLife.new.setRule("12345/3").fps_(5).fadeAmount_(1).play;
a.stop;

//coral
a = ModernLife.new.setRule("45678/3").fps_(25).fadeAmount_(1).play;
a.stop;

//replicator, every pattern is replicated by a copy of itself.
//clear the scene with c and draw a pattern, press space, watch in awe.
a = ModernLife.new.setRule("1357/1357").fps_(10).fadeAmount_(1);
a.stop;</pre>

<p><div class='image'><img src='http://www.squib-box.com/fr/computerdotplay/seminars/seminar4/seminar 4.039.png'/><br><b>L-system Tree - bentrubewriter.files.wordpress.com</b></div>
<div class='image'><img src='http://www.squib-box.com/fr/computerdotplay/seminars/seminar4/seminar 4.040.png'/></div>

<p><strong>LSystems</strong><pre class='code prettyprint lang-sc'>// simple example, fibonacci numbers
a = LSys("A", ["A" -&gt; "B", "B" -&gt; "AB"]);
10.do({ a.applyRules(1).postln; });</pre>
<ul>
<li>variables : 0, 1<li>constants: [, ]<li>axiom : 0<li>rules : (1 → 11), (0 → 1[0]0)</ul>

<p><strong>Context free examples</strong>:<pre class='code prettyprint lang-sc'>//Koch Snowflake
(
a = LSys("F--F--F", ["F" -&gt; "F+F--F+F"]);
k = a.applyRules(4);
LSPlant(80@170, 90, argAngle: 60).drawSize_(4).draw(k);
)

//Dragon Curve
(
a = LSys("L", ["L" -&gt; "L+R+", "R" -&gt; "-L-R"]);
k = a.applyRules(11);÷
LSPlant(180@270, 180, argAngle: 90).drawSize_(4).draw(k);
)

//Sierpinsky triangle
(
a = LSys("L", ["L" -&gt; "R+L+R", "R" -&gt; "L-R-L"]);
k = a.applyRules(6);
LSPlant(60@400, 30, argAngle: 60).drawSize_(6).draw(k);
)

//Islands and Lakes from Algorithmic Beauty of Plants fig. 1.8.
(
a = LSys("F+F+F+F", ["F" -&gt; "F+f-FF+F+FF+Ff+FF-f+FF-F-FF-Ff-FFF", "f" -&gt; "ffffff"]);
k = a.applyRules(2);
LSPlant(360@350, 0, argAngle: 90).drawSize_(6).draw(k);
)

//Quadratic Snowflake from A.B.O.P. fig. 1.7b
(
a = LSys("F", ["F" -&gt; "F+F-F-F+F"]);
k = a.applyRules(5);
LSPlant(20@350, 90, 90, Rect(300, 300, 530, 500), { Color.rand; }).drawSize_(2).draw(k);
)

//Fig 1.9a. from A.B.O.P.
(
a = LSys("F-F-F-F", ["F" -&gt; "FF-F-F-F-F-F+F"]);
k = a.applyRules(3).postln;
LSPlant(270@120, 90, 90, argColor: { Color.rand; }).drawSize_(6).draw(k);
)</pre>

<p><strong>Context sensitive example</strong>:<pre class='code prettyprint lang-sc'>//Signal propagation throughout a string of symbols:

(
a = LSys("baaaaaaaaaaaaaaaa", ["b&lt;a" -&gt; "b", "b" -&gt; "a"]);
16.do
({
    a.applyRules(1).postln;
});
)</pre>

<p>For the syntax of the context sensitive rule definitions, refer to page 30 in the <a href="http://algorithmicbotany.org/papers/abop/abop.pdf">Algorithmic Beauty of Plants</a>.
<p>Branching (bracketed) examples:<pre class='code prettyprint lang-sc'>//Tree b from fig 1.24 in A.B.O.P.
(
a = LSys("F", ["F" -&gt; "F[+F]F[-F][F]"]);
k = a.applyRules(5).postln;
LSPlant
    (
        argAngle: 20,
        argColor:
            {
                [
                    Color.green(0.6.rand + 0.4),
                    Color.gray(0.6.rand)
                ].choose;
            }
    ).drawSize_(6).draw(k);
)

//Tree c from fig 1.24 in A.B.O.P.
(
a = LSys("F", ["F" -&gt; "FF-[-F+F+F]+[+F-F-F]"]);
k = a.applyRules(4).postln;
LSPlant
    (
        argAngle: 22.5,
        argColor:
            {
                [
                    Color.green(0.6.rand + 0.4),
                    Color.gray(0.6.rand)
                ].choose;
            }
    ).drawSize_(6).draw(k);
)


//another tree
(
a = LSys("F", ["F" -&gt; "FF+[+F-F-F]-[-F+F+F]"]);
k = a.applyRules(5);
LSPlant
    (
        argAngle: 22.5,
        argColor:
            {
                [
                    Color.green(0.6.rand + 0.4),
                    Color.gray(0.6.rand)
                ].choose;
            }
    ).drawSize_(6).draw(k);
)


(
a = LSys("F", ["F" -&gt; "F[-FF]F[+FF]F"]);
k = a.applyRules(5);
LSPlant
    (
        argAngle: 22.5,
        argColor:
            {
                [
                    Color.green(0.6.rand + 0.4),
                    Color.gray(0.6.rand)
                ].choose;
            }
    ).drawSize_(6).draw(k);
)

//Tree f from fig 1.24 in A.B.O.P.
(
a = LSys("X", ["X" -&gt; "F-[[X]+X]+F[+FX]-X", "F" -&gt; "FF"]);
k = a.applyRules(5).postln;
LSPlant
    (
        argAngle: 22.5,
        argColor:
            {
                [
                    Color.green(0.6.rand + 0.4),
                    Color.gray(0.6.rand)
                ].choose;
            }
    ).drawSize_(4).draw(k);
)</pre>

<p><strong>Examples</strong>
<p>A simple example: We want to reach to a target value (4242) with a mathematical expression composed of 17 operators and digits. So the expression is composed in [digit operator digit operator ...] formation. We are searching for the expression. poolSize is 100, and we will find the fittest expression after 100 generations.<pre class='code prettyprint lang-sc'>(
//this will take a few seconds to complete.
var digits = "0123456789"; //allowed digits
var operators = "+-*/%"; //allowed operators
var poolSize = 100, chromLength = 17;
var target = 4242;
var numGenerations = 100;
var inGeneration = 0; //current generation
var randChromFunc =
    {
        var randChrom = List.new;
        chromLength.do
        ({|cnt|
            if(cnt.even,
            {
                randChrom.add(digits.choose);
            },
            {
                randChrom.add(operators.choose);
            });
        });
        randChrom;
    };
var fitnessFunc =
    {|chrom|
        var result;
        chrom = chrom.as(String);
        //if the result is inf (divide by zero etc), bigger numbers are
        //weaker (we return the reciprocal) here so they won't be fit.
        //We set NaN's as inf.
        result = (chrom.interpret - target).abs;
        if(result.isNaN, { result = inf; });
        result.reciprocal; //smaller results (difference from target) should be fitter
    };
var mutationFunc =
    {|chrom|
        var index = chromLength.rand;
        if(index.even, { chrom[index] = digits.choose; }, { chrom[index] = operators.choose; });
        chrom;
    };
    var gaInstance = GAWorkbench(poolSize, randChromFunc, fitnessFunc, mutationFunc);
gaInstance.mutationProb = 0.1;
block
({|break|
    numGenerations.do
    ({
        gaInstance.rateFitness;
        //if an exact solution is found, break the loop.
        if(gaInstance.genePool[0].as(String).interpret == target, { break.value; });
        gaInstance.crossover;
        inGeneration = inGeneration + 1;
    });
});
gaInstance.rateFitness;
"Target value was % and reached value after % generations is: %"
    .format(target, inGeneration, gaInstance.genePool[0].as(String).interpret).postln;
("The operation was:" + gaInstance.genePool[0].as(String)).postln;
)</pre>

<p>It can be observed that the algorithm sometimes converges to an exact solution pretty quickly, and other times it gets stuck in a local optimum. To overcome that, one can use parallel GA's where more than one GAWorkbench instance works on the same problem with different initial random pools for a few generations, and then their fittest members can be mixed into a new pool to be iterated further.
<p><strong>Another example</strong>:
<p>Travelling salesman problem. We have 25 cities to visit, we start from the red city and want to visit each city only and only once, then come back to our origin in the shortest path possible. With a brute-force approach, one needs to check 15511210043330985984000000 different paths to find the shortest route (for 25 cities), (which is not feasible) so genetic algorithms provides us an easy search method for finding a nice enough path in very little time. This code will show the fittest route in each generation for randomly selected points in a 2d space. Be aware that there is no way to find out that a given solution is the global optimum. In fact, the method used here converges to a local optimum pretty quickly but hopefully the route will converge to something with an high fitness. The chromosome encoding scheme here is left as an exercise for the reader.<pre class='code prettyprint lang-sc'>(
var numPoints, points, randChromFunc, mutationFunc, fitnessFunc,
chromInterpreter, gaInstance, win, view, drawPaths, routine;
//problem
numPoints = 25;
points = { 500.0.rand@500.0.rand } ! numPoints;
//ga funcs
randChromFunc =
    {
        (numPoints - 1, (numPoints - 2) .. 1).collect
        ({|cnt|
            (exprand(1, cnt) - 1).floor;
        });
    };

mutationFunc =
    {|chrom|
        var randIndex = (chrom.size - 1).rand;
        chrom[randIndex] = (exprand(1, (numPoints - randIndex - 2)) - 1).floor;
        chrom;
    };
fitnessFunc =
    {|chrom|
        var pathIndexes = chromInterpreter.value(chrom);
        var totalDistance = 0;
        (numPoints).do
        ({|cnt|
            totalDistance = totalDistance + points[pathIndexes[cnt]].dist(points[pathIndexes[(cnt+1) % numPoints]]);
        });
        totalDistance.reciprocal; //shorter paths are better
    };
chromInterpreter = //this chunk of code is shared between fitness function and visualization
    {|chrom|
        var ptsToGo = (1, 2 .. numPoints - 1);
        var travellerIsIn = 0;
        var currentDistances, curDistOrders;
        var pathIndexes = List.new;
        (numPoints - 1).do
        ({|inHop|
            currentDistances =
                ptsToGo.collect
                ({|pntIndex|
                    points[travellerIsIn].dist(points[pntIndex]);
                });
            curDistOrders = currentDistances.order.order;
            pathIndexes.add(ptsToGo[curDistOrders.detectIndex({|item| item == chrom[inHop]; })]);
            ptsToGo.remove(pathIndexes.last);
            travellerIsIn = pathIndexes.last;
        });
        pathIndexes.add(0);
        pathIndexes;
    };
gaInstance = GAWorkbench.new(100, randChromFunc, fitnessFunc, mutationFunc);
gaInstance.mutationProb = 0.2;
win = Window.new("TSP", Rect(300, 300, 500, 500));
view = UserView(win, win.view.bounds).background_(Color.black)
    .drawFunc_
    ({
        var fittest = gaInstance.genePool[0];
        points.do
        ({|pnt, cnt|
            Pen.color = if(cnt == 0, { Color.red; }, { Color.white; });
            Pen.fillOval(Rect(pnt.x - 4, pnt.y - 4, 8, 8));
        });
        drawPaths.value(fittest);
    });
drawPaths =
    {|chrom|
        var pathIndexes = chromInterpreter.value(chrom);
            (numPoints).do
        ({|cnt|
            Pen.line(points[pathIndexes[cnt]], points[pathIndexes[(cnt+1) % numPoints]]);
        });
        Pen.stroke;
    };
win.front;
win.onClose_({ routine.stop; });
routine = {
    inf.do
    ({
        gaInstance.crossover;
        gaInstance.rateFitness;
        win.refresh;
        0.1.wait;
    });
}.fork(AppClock);
)</pre>
<div class='image'><img src='http://www.squib-box.com/fr/computerdotplay/seminars/seminar4/seminar 4.016.png'/><br><b>Andrey Markov - wikipedia.org</b></div>
<div class='image'><img src='http://www.squib-box.com/fr/computerdotplay/seminars/seminar4/seminar 4.021.png'/></div>

<p><pre class='code prettyprint lang-sc'>Quarks.gui; //install MathLib

//There are two classes for doing Markov Chains:
MarkovSet
MarkovSetN

//simple example
(
m = MarkovSet([
    [60, [67, 65, 64], [0.5,0.3, 0.2]], //element, nextElement, weights
    [67, [60], [1]],
    [65, [67, 64], [0.5,0.5]],
    [64, [60,65, 67], [0.2,0.4,0.4]]
    ]);
)

Pbind(\midinote, Pfsm2(m), \dur, 0.5).play; //Pfsm2 creates a pattern from Markov Set

(
m = MarkovSet([
[60, [62], [1]],
[62, [60, 63], [0.5, 0.5]],
[63, [60, 65], [1, 1]],
[65, [60, 65, 67], [1, 4, 1]],
[67, [70], [1]],
[70, [67, 69], [1, 2]],
[69, [67, 72], [1, 2]],
[72, [67, 72, 60], [1,4,2]]
]);
)

~mark = Pfsm2(m).asStream;
~dur = ~mark.collect({|item|
    case
    {[60,63,67,69].includes(item);} {1}
    {[62,65,72].includes(item);} {0.5}
    {item == 70;} {1.5}
})

Pdef(\mark, Pbind(\instrument, \sinePerc, \midinote, ~mark, \dur, ~dur*0.33)).play; //Pfsm2 creates a pattern from Markov Set

//another example
(
m = MarkovSet([
[60, [62], [1]],
[62, [60, 63], [1, 1]],
[63, [60, 65], [1, 1]],
[65, [60, 65, 67], [1, 4, 1]],
[67, [70], [1]],
[70, [67, 69], [1, 2]],
[69, [67, 72], [1, 2]],
[72, [67, 72, 60], [1,4,2]]
]);
~mark = Pfsm2(m).asStream;
~dur = ~mark.collect({|item|
    case
    {[60,63,67,69].includes(item);} {1}
    {[62,65,72].includes(item);} {0.5}
    {item == 70;} {1.5}
})
)

Pdef(\mark, Pbind(\instrument, \sinePerc, \midinote, ~mark, \dur, ~dur*0.33))

// training by a stream
m = MarkovSet.fill(100, Pseq([1, 2, 3, 4, Prand([5, 55, 555])], inf).asStream);
8.do { m.next(1).postln };
8.do { m.next(4).postln };
8.do { m.next(55).postln };

// training bit by bit
m = MarkovSet.new;
m.read(\x, \y);
m.read(\x, \z);
m.read(\z, \abcde);
m.read(\y, nil);

8.do { m.next(\x).postln };
8.do { m.next(\y).postln };
8.do { m.next(\z).postln };

m.read(\y, \mmmm);
8.do { m.next(\y).postln }; // now it sometimes terminates

m.remove(\y, \mmmm);
8.do { m.next(\y).postln };

//now a musical example:
//this is our melody which we will train the markov with
~notes = [ 0, 0, 7, 7, 9, 9, 7, 7, 5, 5, 4, 4, 2, 2, 0, 0 ] + 60;

Pbind(\midinote, Pseq(~notes, 1), \dur, 0.3).play

~pairs = ~notes.slide(2).slice;

~num = (~pairs.size/2);
~secondPair = Array.iota(~num.asInteger,2);
~trainMe = ~pairs.reshapeLike(~secondPair);

m = MarkovSet.new;

~trainMe.do{|item| m.read(item[0], item[1]) };

Pbind(\midinote, Pfsm2(m), \dur, 0.5).play;

// 2nd order MarkovSet
(
m = MarkovSetN([
            [[100, 120], [120, 130]],
            [[120, 100], [100, 1900]]
        ], 2);
)

8.do { m.next([100, 120]).postln };
8.do { m.next([120, 100]).postln };

// training by a stream
m = MarkovSetN.fill(100, Pseq([1, 2, 3, 4, Prand([5, 55, 555])], inf).asStream, 2);
8.do { m.next([1,2]).postln };
8.do { m.next([3,4]).postln };
8.do { m.next([4,5]).postln };</pre>
<div class='image'><img src='http://www.squib-box.com/fr/computerdotplay/seminars/seminar2/seminar2.036.png'/><br><b>David Cope - alchetron.com</b></div>

<p><div class='image'><img src='http://www.squib-box.com/fr/computerdotplay/seminars/seminar2/seminar2.037.png'/></div>

<p><pre class='code prettyprint lang-sc'>"open http://youtu.be/yFImmDsNGdE?t=45s".unixCmd; //Tech Closeup TV
"open http://youtu.be/t6WeiyvAiYQ".unixCmd; //Chopin style
"open http://youtu.be/R-_9zSSQK3o".unixCmd; //Joplin style</pre>
<div class='doclink'>helpfile source: <a href='file:///Users/federicoreuben/Library/Application Support/SuperCollider/Extensions/Cyborg/HelpSource/Cyborg/Seminars/Machine Learning.schelp'>/Users/federicoreuben/Library/Application Support/SuperCollider/Extensions/Cyborg/HelpSource/Cyborg/Seminars/Machine Learning.schelp</a><br>link::Cyborg/Seminars/Machine Learning::<br>sc version: 3.8.0</div></div></body></html>