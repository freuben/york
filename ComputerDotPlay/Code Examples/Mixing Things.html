<html><head><title>Mixing Things</title>
<link rel='stylesheet' href='./../../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../../scdoc.js' type='text/javascript'></script>
<script src='./../../docmap.js' type='text/javascript'></script>
<script src='./../../prettify.js' type='text/javascript'></script>
<script src='./../../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./../..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider COMPUTERDOTPLAY/CODE EXAMPLES (extension)</div>
<div id='categories'><a href='./../../Browse.html#Tutorials/ComputerDotPlay'>Tutorials/ComputerDotPlay</a></div>
<h1>Mixing Things</h1>
<div id='summary'>ComputerDotPlay</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../../ComputerDotPlay.html">ComputerDotPlay</a>, <a href="./../../ComputerDotPlay/Lectures/Digital Effects">Digital Effects</a>, <a href="./../../ComputerDotPlay/Practicals/Buses and Ndefs.html">Buses and Ndefs</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#Mix%20things%20up'>Mix things up</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Example'>Example</a></li>
<ul class='toc'></ul></ul></div><h2><a class='anchor' name='Mix%20things%20up'>Mix things up</a></h2>

<p>First, run this piece of code to load the Synths and FXs:<pre class='code prettyprint lang-sc'>(
~synthDefs = [
    SynthDef(\prophet5pwmstrings,{|out= 0 freq = 440 bend = 0 amp = 1.0 gate=1
        lforate = 10 lfowidth= 0.5 cutoff= 12000 rq=0.5 pan = 0.0|
        var lfo, pulse, filter, env;
        lfo = LFTri.kr(lforate*[1,1.01],Rand(0,2.0)!2);
        pulse = Pulse.ar((freq*bend.lag(0.1).midiratio)*[1,1.01],lfo*lfowidth+0.5);
        filter = RLPF.ar(pulse,cutoff,rq);
        env = Env.adsr(0.01,0.0,1.0,0.5).kr(2,gate);
        Out.ar(out,Pan2.ar(Mix(filter)*env*amp*0.5,pan));
    }),
    SynthDef(\singleoscillatorwobble,{|out= 0 freq = 440 bend = 0 amp = 1.0 gate=1
        lforate = 10 lfowidth= 0.5 cutoff= 12000 rq=0.5 pan=0.0|
        var lfo, pulse, filter, env;
        lfo = LFTri.kr(lforate,Rand(0,2.0)!2);
        pulse = Pulse.ar((freq*bend.lag(0.1).midiratio)*(1.0+(lfowidth*lfo)),0.5);
        filter = RLPF.ar(pulse,cutoff,rq);
        env = Env.adsr(0.01,0.0,1.0,0.5).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp*0.5,pan));
    }),
    SynthDef(\trianglewavebells,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1 lforate = 10
        lfowidth= 0.0 cutoff= 100 rq=0.5 pan=0.0|
        var osc1, osc2, vibrato, filter, env;
        vibrato = SinOsc.ar(lforate,Rand(0,2.0));
        osc1 = Saw.ar((freq*bend.lag(0.1).midiratio)*(1.0+(lfowidth*vibrato)),0.75);
        osc2 = Mix(LFTri.ar(((freq*bend.lag(0.1).midiratio).cpsmidi+[11.9,12.1]).midicps));
        filter = RHPF.ar((osc1+(osc2*0.5))*0.5,cutoff,rq);
        env = Env.adsr(0.01,0.1,1.0,0.5).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\organdonor,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1 lforate = 10
        lfowidth= 0.0 cutoff= 100 rq=0.5 pan=0.0|
        var vibrato, pulse, filter, env;
        vibrato = SinOsc.ar(lforate,Rand(0,2.0));
        pulse = Mix(VarSaw.ar(([1,1.9953843530485,3.0139733629359]
            *(freq*bend.lag(0.1).midiratio))*(1.0+(lfowidth*vibrato)),Rand(0.0,1.0)!3,
        Rand(0.3,0.5)!3,[1.0,0.7,0.3]))*0.5;
        filter = RLPF.ar(pulse,cutoff,rq);
        env = Env.adsr(0.01,0.5,1.0,0.5).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\werkit,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1 cutoff= 100
        rq=0.1 pan=0.0|
        var source, filter, env;
        source = WhiteNoise.ar;
        filter = BLowPass4.ar(source,(freq*bend.lag(0.1).midiratio),rq)*0.3;
        env = Env([0,1,0.5,0.0],[0.02,0.1,0.1]).kr(2);
        Out.ar(out,Pan2.ar((0.7*filter+(0.3*filter.distort))*env*amp,pan));
    }),
    SynthDef(\laserbeam,{|out= 0 freq = 440 bend = 0 amp = 0.1 atkTime= 0.04
        gate=1 pan=0.0|
        var osc1, freqenv, ampenv;
        freqenv = Env([4,0.5,1,1],[atkTime,0.01,1.0]).kr(2);
        osc1 = LFTri.ar((freq*bend.lag(0.1).midiratio)*freqenv);
        //env = Env.adsr(0.01,0.0,1.0,0.1).kr(2,gate);
        //no gate, fixed envelope size
        ampenv = Env([0,1,0.5,0.0],[0.02,0.2,0.1]).kr(2);
        Out.ar(out,Pan2.ar(osc1*ampenv*amp,pan));
    }),
    SynthDef(\moogbasstone,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1 cutoff= 1000
        gain=2.0 lag = 0.01 pan=0.0, lagFilter=0.01|
        var osc, filter, env, filterenv;
        osc = Mix(VarSaw.ar((freq*bend.lag(0.1).midiratio).lag(lag)*[1.0,1.001,2.0],
            Rand(0.0,1.0)!3,Rand(0.5,0.75)!3,0.33));
        filterenv = Env.adsr(0.2,0.0,1.0,0.2).kr(2,gate);
        filter =  MoogFF.ar(osc,cutoff.lag(lagFilter)*(1.0+(0.5*filterenv)),gain);
        env = Env.adsr(0.001,0.3,0.9,0.2).kr(2,gate);
        Out.ar(out,Pan2.ar((0.7*filter+(0.3*filter.distort))*env*amp*1.5,pan));
    }),
    SynthDef(\moogbasstone2,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        atkTime= 0.2 fenv=0.5 cutoff= 1000 gain=2.0 pan=0.0|
        var osc, filter, env, filterenv;
        osc = Mix(Pulse.ar((freq*bend.lag(0.1).midiratio).lag(0.05)*[1.0,1.001,2.0],
            Rand(0.45,0.5)!3,0.33));
        filterenv = Env.adsr(atkTime,0.0,1.0,0.2).kr(2,gate);
        filter =  MoogFF.ar(osc,cutoff*(1.0+(fenv*filterenv)),gain);
        env = Env.adsr(0.001,0.3,0.9,0.2).kr(2,gate);
        Out.ar(out,Pan2.ar((0.7*filter+(0.3*filter.distort))*env*amp,pan));
    }),
    SynthDef(\mrostinato,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1 lforate = 10
        lfowidth= 0.5 pan = 0.0|
        var lfo, pulse, filter, env;
        lfo = LFTri.kr(lforate,Rand(0,2.0)!3);
        pulse = Pulse.ar((freq*bend.lag(0.1).midiratio)*[1,1.01,0.5],lfo*lfowidth+0.5);
        env = Env.adsr(0.01,0.05,0.5,0.1).kr(2,gate);
        Out.ar(out,Pan2.ar(Mix(pulse)*env*amp,pan));
    }),
    SynthDef(\plastickystrings,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        lforate = 5900 lfowidth= 0.01 cutoff= 12000 rq=0.5 pan=0.0|
        var lfo, saw, filter, env;
        lfo = LFTri.ar(lforate,Rand(0,2.0));
        saw = Saw.ar((freq*bend.lag(0.1).midiratio)*(1.0+(lfowidth*lfo)),0.5);
        filter = BHiPass.ar(saw,(freq*bend.lag(0.1).midiratio),rq);     //or using cutoff
        env = Env.adsr(0.4,0.0,1.0,1.0).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\handclapsmash,{|out= 0 amp = 0.1 gate=1 cutoff= 12000 rq=0.5
        reltime=0.5 pan=0.0|
        var noise, filter, filterenv, env;
        noise = WhiteNoise.ar;
        filterenv = Env([0.0,1.0,0.3,0.0],[0.0,0.3,0.3]).kr;
        filter = BHiPass.ar(RLPF.ar(noise,cutoff*filterenv,rq),150);
        filter = BPeakEQ.ar(filter,440,1.0,8);
        filter = BPeakEQ.ar(filter,1200,1.0,14);
        env = Env.perc(0.005,reltime).kr(2);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\handclapsmash2,{|out= 0 amp = 0.1 gate=1 cutoff= 12000 cutoff2=10000
        rq=0.5 mod=0.0 modrate=50 reltime=0.7 pan=0.0|
        var noise, filter, filterenv, modulation, env;
        noise = WhiteNoise.ar;
        filterenv = Env([0.0,1.0,0.3,0.0],[0.0,0.3,0.3]).kr;
        modulation = (LFSaw.ar(modrate).range(0.0,1.0))
        *Env([1,1,0,0],[0.1,0.0,1.0]).kr;
        filter = BHiPass.ar(RLPF.ar(noise,cutoff*filterenv+ (cutoff2*mod*modulation),rq),150);
        filter = BPeakEQ.ar(filter,440,1.0,8);
        filter = BPeakEQ.ar(filter,1200,1.0,14);
        env = Env.perc(0.005,reltime).kr(2);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\bassfoundation,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff= 1000 rq=0.5 pan=0.0|
        var osc, filter, env, filterenv;
        osc = Saw.ar((freq*bend.lag(0.1).midiratio));
        filterenv = Env.adsr(0.0,0.5,0.2,0.2).kr(2,gate);
        filter =  RLPF.ar(osc,cutoff*filterenv+100,rq);
        env = Env.adsr(0.01,0.0,0.9,0.05).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp*2,pan));
    }),
    SynthDef(\basshighend,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff= 3000 rq=0.1 drive = 2.0 pan=0.0|
        var osc, filter, env, filterenv;
        var ab;
        osc = Mix(VarSaw.ar((freq*bend.lag(0.1).midiratio)*[0.25,1,1.5],
            Rand(0.0,1.0)!3,0.9,[0.5,0.4,0.1]));
        filterenv = Env.adsr(0.0,0.5,0.2,0.2).kr(2,gate);
        filter =  RLPF.ar(osc,cutoff*filterenv+100,rq);
        filter = filter.distort.softclip;
        ab = abs(filter);
        filter = (filter*(ab + drive)/(filter ** 2 + (drive - 1) * ab + 1));
        filter = BLowShelf.ar(filter,300,1.0,-12);
        filter = BPeakEQ.ar(filter,1600,1.0,-6);
        env = Env.adsr(0.01,0.0,0.9,0.05).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp*2,pan));
    }),
    SynthDef(\winwoodlead,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff=8000 rq=0.8 lfowidth=0.01 lforate= 8 lag=0.01 pan=0.0|
        var pulse, filter, env, lfo;
        lfo = LFTri.kr(lforate,Rand(0,2.0)!2);
        pulse = Mix(Pulse.ar(((freq*bend.lag(0.1).midiratio).lag(lag))*[1,1.001]
            *(1.0+(lfowidth*lfo)),[0.2,0.19]))*0.5;
        filter =  RLPF.ar(pulse,cutoff,rq);
        filter = BLowShelf.ar(filter,351,1.0,-9);
        env = Env.adsr(0.01,0.0,0.9,0.05).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\spookystrings,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff=8000 rq=0.2 lfowidth=0.01 lforate=3.8 pan=0.0|
        var pulse, filter, env, lfo;
        lfo = LFTri.kr(lforate,Rand(0,2.0)!2);
        pulse = Mix(Saw.ar((freq*bend.lag(0.1).midiratio)*[1,1.001]
            *[1.0,1.0+(lfowidth*lfo)]))*0.5;
        filter = BHiPass.ar(pulse,cutoff,rq);
        env = Env.adsr(0.1,0.0,1.0,3).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\spookystrings2,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff=8000 rq=0.2 pan=0.0|
        var saw, pulse, filter, env, lfo, pulsewidthlfo;
        lfo = LFTri.kr([3.5,5],Rand(0,2.0)!2);
        pulsewidthlfo = SinOsc.kr(4.5);
        saw = Saw.ar((freq*bend.lag(0.1).midiratio)*(1.0+(0.052*lfo[0])));
        pulse = Pulse.ar((freq*bend.lag(0.1).midiratio)*(1.0+(0.072*lfo[1])),
            pulsewidthlfo*0.25+0.5);
        pulse = 0.5*(saw+pulse);
        filter = BLowPass.ar(pulse,XLine.kr(678,cutoff,0.378),rq);
        env = Env.adsr(0.1,0.0,1.0,3).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\synchronicity,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff=8000 rq=0.2 pan=0.0|
        var pulse, filter, env, slavefreq;
        slavefreq = Env([1,5,1],[0.04,0.9]).kr*(freq*bend.lag(0.1).midiratio);
        pulse = SyncSaw.ar((freq*bend.lag(0.1).midiratio),slavefreq);
        filter = BLowPass.ar(pulse,cutoff,rq);
        env = Env.adsr(0.01,0.0,1.0,0.1).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\situationsynth,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff=8000 rq=0.8 lfowidth=0.001 lforate= 3.3 pan=0.0|
        var pulse, filter, env, filterenv, lfo;
        lfo = LFTri.kr(lforate,Rand(0,2.0)!2);
        pulse = Mix(Pulse.ar(((((freq*bend.lag(0.1).midiratio).cpsmidi)+[0,0.14])
            +(lfo*lfowidth)).midicps,[0.5,0.51]+(lfowidth*lfo)))*0.5;
        filterenv = Env([0.0,1.0,0.3,0.0],[0.005,0.57,0.1],-3).kr;
        filter =  RLPF.ar(pulse,100+(filterenv*cutoff),rq);
        env = Env.adsr(0.002,0.57,1.0,0.3).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\ressquares,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff=8000 rq=0.8 pan=0.0|
        var pulse, filter, env;
        pulse = Mix(Pulse.ar( (((freq*bend.lag(0.1).midiratio).cpsmidi)
            +[0,0.02]).midicps, 0.5))*0.5;
        filter =  BLowPass.ar(pulse,100+cutoff,rq);
        env = Env.adsr(0.002,0.1,1.0,0.2).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\whoorgan,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff=8000 rq=0.8 pan=0.0|
        var osc, filter, env;
        var basefreq =  (((freq*bend.lag(0.1).midiratio).cpsmidi)+[0,0.1]).midicps;
        osc = Mix.fill(10,{|i| SinOsc.ar(basefreq*(i+1),0.0,(0.25+(0.75
            *LFNoise0.kr(10.1+i,0.5,0.5)))/(1.0+(0.5*i)))})*0.2;
        filter =  BLowPass.ar(osc,2000+(amp*cutoff),rq);
        env = Env.adsr(0.02,0.1,0.9,1.0).kr(2,gate);
        Out.ar(out,Pan2.ar(Mix(filter)*env*amp,pan));
    }),
    SynthDef(\whoorgan2,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff=8000 rq=0.8 pan=0.0|
        var osc, filter, env;
        var basefreq =  (((freq*bend.lag(0.1).midiratio).cpsmidi)+[0,0.1]).midicps;
        osc = Mix(Blip.ar(basefreq,16))*0.5;
        filter =  BLowPass.ar(osc,2000+(amp*cutoff),rq);
        env = Env.adsr(0.02,0.1,0.9,1.0).kr(2,gate);
        Out.ar(out,Pan2.ar(Mix(filter)*env*amp,pan));
    }),
    SynthDef(\eightoeightkick,{|out= 0 freq = 440 bend = 0 amp = 0.1 ringtime=10.0
        reltime=1.0 dist = 0.1 pan=0.0|
        var impulse, filter, env;
        impulse = Impulse.ar(0);
        filter = Ringz.ar(impulse,XLine.ar((freq*bend.lag(0.1).midiratio),60,0.1),ringtime);
        env = Env.perc(0.001,reltime).kr(2);
        filter = (1.0-dist)*filter + (dist*(filter.distort));
        Out.ar(out,Pan2.ar(filter*env*amp,pan));
    }),
    SynthDef(\pwmbling,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1 lforate = 4.85
        lfowidth= 0.5 cutoff= 12000 rq=0.25 pan = 0.0|
        var lfo, pulse, filter, env;
        var basefreq =  (((freq*bend.lag(0.1).midiratio).cpsmidi)+[0,12.12]).midicps;
        lfo = LFTri.kr(lforate*[1,1.01],Rand(0,2.0)!2);
        pulse = Pulse.ar(basefreq,lfo*lfowidth+0.5);
        env = Env.adsr(0.0,1.0,0.2,1.5).kr(2,gate);
        filter = RLPF.ar(pulse,(cutoff*(env.squared))+100,rq);
        Out.ar(out,Pan2.ar(Mix(filter)*env*amp,pan));
    }),
    SynthDef(\tonewheeltwo,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        lforate = 4.85 lfowidth= 0.1 cutoff= 5000 rq=0.25 pan = 0.0|
        var lfo, pulse, filter, env;
        lfo = LFTri.kr(lforate*[1,1.01],Rand(0,2.0)!2);
        pulse = Pulse.ar( ((((freq*bend.lag(0.1).midiratio)*[1,3]).cpsmidi)
            + (lfo*lfowidth)).midicps,[0.5,0.51],[0.4,0.6]);
        env = Env.adsr(0.0,0.0,1.0,0.1).kr(2,gate);
        filter = BLowPass4.ar(pulse,cutoff,rq);
        filter= BPeakEQ.ar(filter,500,1.0,3);
        Out.ar(out,Pan2.ar(Mix(filter)*env*amp,pan));
    }),
    SynthDef(\everythingrhodes,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        lforate = 4.85 lfowidth= 0.5 cutoff= 2000 rq=0.5 pan = 0.0|
        var pulse, filter, env;
        pulse = Mix.ar(Pulse.ar((freq*bend.lag(0.1).midiratio)
            *[1,33.5.midiratio],[0.2,0.1],[0.7,0.3]));
        env = Env.adsr(0.0,1.0,0.8,3.0).kr(2,gate);
        filter = BLowPass4.ar(pulse,(cutoff)+200+(freq),rq);
        Out.ar(out,Pan2.ar(Mix.ar(filter)*env*amp,pan));
    }),
    SynthDef(\justwannahavefun,{|out= 0 freq = 440 bend = 0 amp = 0.1
        ringtime=10.0 pan=0.0|
        var impulse, filter, env;
        impulse = Impulse.ar(0);
        filter = Ringz.ar(impulse,((freq*bend.lag(0.1).midiratio).cpsmidi +
            (Rand(0.2,1.2)*SinOsc.kr(Rand(10,50)))).midicps,ringtime);
        env = Env([0.0,1.0,1.0,0.0],[0.001,0.04,0.04]).kr(2);
        Out.ar(out,Pan2.ar((filter.softclip(0.9))*env*amp,pan));
    }),
    SynthDef(\spacetheremin,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        lforate = 6 lfowidth= 0.5 cutoff= 4000 rq=0.25 lag=0.1 pan=0.0|
        var lfo, osc, filter, env;
        lfo = LFTri.kr(lforate+(LFNoise1.kr(5,0.3,0.3)),Rand(0,2.0));
        osc = Saw.ar(((freq*bend.lag(0.1).midiratio).lag(lag).cpsmidi
            +(lfo*lfowidth)).midicps,0.5);
        filter = BLowPass4.ar(osc,cutoff.lag(lag*4),rq);
        env = Env.adsr(0.6,0.0,1.0,0.05).kr(2,gate);
        Out.ar(out,Pan2.ar(filter*env*amp.lag(lag*4),pan));
    }),
    SynthDef(\fatvelocitybass,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff= 12000 rq=0.25 lag=0.01 pan = 0.0|
        var lfo, osc, filter, env;
        var basefreq =  (((freq*bend.lag(0.1).midiratio).lag(lag).cpsmidi)
            +[0,11.95,31.03]).midicps;
        osc = Saw.ar(basefreq,[0.5,0.4,0.1]);
        env = Env.adsr(0.01,1.0,1.0,0.25).kr(2,gate);
        filter = BLowPass4.ar(osc,100+((amp.squared)*((freq*bend.lag(0.1).midiratio)
            +cutoff)),rq);
        Out.ar(out,Pan2.ar(Mix(filter)*env*amp*0.8,pan));
    }),
    SynthDef(\fatvelocitybass2,{|out= 0 freq = 440 bend = 0 amp = 0.1 gate=1
        cutoff= 12000 rq=0.25 lag=0.01 pan = 0.0|
        var lfo, osc, filter, env;
        var basefreq =  (((freq*bend.lag(0.1).midiratio).lag(lag).cpsmidi)
            +[0,11.95,31.03]).midicps;
        osc = Saw.ar(basefreq,[0.5,0.4,0.1])+PinkNoise.ar(Line.kr(1.0,0,0.03));
        env = Env.adsr(0.01,1.0,1.0,0.25).kr(2,gate);
        filter = BLowPass4.ar(osc,100+((amp.squared)*((freq*bend.lag(0.1).midiratio)
            +cutoff)),rq);
        Out.ar(out,Pan2.ar(Mix(filter)*env*amp*0.8,pan));
    }),
    SynthDef(\wavecross1, {|out=0 freq=440 bend=0 attack=0.01 dec=0.4 sus=0.3
        sus2=0.4, rel=2 amp=0.5 pan|
        var wave1, wave2, wave3, wave4, nowFreq;
        var env1,env2,env3,env4, globalEnv;
        env1 = Env([0,1,0],[attack,dec]).kr;
        env2 = Env([0,0,1,0],[attack,dec,sus]).kr;
        env3 = Env([0,0,1,0],[attack+dec,sus,sus2]).kr;
        env4 = Env([0,0,1,0],[attack+dec+sus,sus2,rel]).kr;
        globalEnv = Env([0,1,0.5,0.5,0.4,0],[attack,dec,sus,sus2,rel]).kr(2);
        nowFreq = (freq*bend.lag(0.1).midiratio);
        wave1 = Pulse.ar(nowFreq)*env1;
        wave2 = Formant.ar(nowFreq)*env2;
        wave3 = Saw.ar(nowFreq)*env3;
        wave4 = SinOsc.ar(nowFreq)*env4;
        Out.ar(out, Pan2.ar((wave1 + wave2 + wave3 + wave4), pan)*globalEnv*amp);
    }),
    SynthDef(\wavestack1, {|out=0 freq=440 bend=0 attack=1 sus=1 rel=1
        amp=0.5 pan|
        var globalEnv, harm, signal, envArr;
        var wave1, wave2, wave3, wave4, nowFreq;
        globalEnv = Env.linen(0.01*attack,0.3*sus,2*rel).kr(2);
        [0.01*attack,0.3*sus,2*rel].sum*[[0.3*attack,0.6*sus,0.1*rel],[0.1*attack,0.5
            *sus,0.4*rel],[0.01*attack,0.3*sus,0.69*rel],[0.8*attack,0.1*sus,0.1
            *rel]].do{|item| envArr = envArr.add(Env.linen(item[0], item[1], item[2]))};
        harm = [1,2,3,4];
        nowFreq = (freq*bend.lag(0.1).midiratio);
        wave1 = Pulse.ar(freq*harm[3])*envArr[0].kr;
        wave2 = Formant.ar(freq*harm[1])*envArr[1].kr;
        wave3 = Saw.ar(freq*harm[2])*envArr[2].kr;
        wave4 = SinOsc.ar(freq*harm[0])*envArr[3].kr;
        signal = ((wave1 + wave2 + wave3 + wave4)/4)*globalEnv;
        Out.ar(out, Pan2.ar(signal*amp*2, pan));
    }),
    SynthDef(\simplesine,{|out= 0 freq = 440 bend = 0 amp = 1.0 gate=1 atk=0.01
        dec=0.0 sus=1.0 rel=0.5 pan=0.0|
        var signal, env;
        signal = SinOsc.ar(freq,0,0.5);
        env = Env.adsr(atk,dec,sus,rel).kr(2,gate);
        Out.ar(out, Pan2.ar(signal*env*amp, pan));
    }),
    //add more if you want!
    SynthDef(\pitchshift,{|out= 0 freq = 440 bend = 0 amp = 1.0 gate=1 bus=0
        winSize=0.2 bassfreq=440 pitchDis=0.0, timeDis=0.01|
        var signal, env, in, pan;
        in = SoundIn.ar(bus);
        signal = PitchShift.ar(in, winSize, (freq/bassfreq), pitchDis, timeDis);
        env = Env.linen(0.1,1.0,0.4).kr(2,gate);
        pan = freq.cpsmidi.linlin(21,108,-1,1);
        Out.ar(out, Pan2.ar(signal*env*amp, pan));
    });
];
s.waitForBoot{
    ~synthDefs.do{|item| item.add };
};
//fxs code:
~fxs =
[
    [\pch, {arg in, pitchRatio=1.0, pitchDispertion=0.0, timeDispersion=0.0001,
        lag=5.0, winSize=0.02;
        PitchShift.ar(in, winSize, pitchRatio.lag(lag), pitchDispertion, timeDispersion)
    }, "pitch shifter 1", [{|val| val.linlin(0.0,1,-12,12).round(0.4).midiratio},
        {|val| val.linexp(0.0,1,0.01,2.01)-0.01}, {|val| val.linexp(0.0,1,0.01,2.01)-0.01},
        {|val|val.linlin(0.0,1,0.01,15)}, {|val| val.linlin(0.0,1,0.01,3)}]],
    [\pch2, {arg in, centerpitch=440,bus=0, pitchDispertion=0.0, timeDispersion=0.0,
        lag=0.1, winSize=0.1;
        var freq, hasFreq;
        # freq, hasFreq = Pitch.kr(SoundIn.ar(bus.round(1)), ampThreshold: 0.0, median: 7);
        PitchShift.ar(in, winSize, (freq/centerpitch).lag(lag), pitchDispertion, timeDispersion);
    }, "pitch shifter 2", [{|val| val.linexp(0.0,1,4000,10)}, {|val| val.linlin(0,1,1,8).round(1)},
        {|val| val.linexp(0.0,1,0.01,2.01)-0.01}, {|val| val.linexp(0.0,1,0.01,2.01)-0.01},
        {|val| val.linlin(0.0,1,0.01,15)}, {|val| val.linlin(0.0,1,0.01,3)}]],
    [\pch3, {arg in, centerpitch=440, bus=0, adjvol=4, pitchDispertion=0.0,
        timeDispersion=0.0001, lag=0.1, winSize=0.02;
        var freq, hasFreq, input, amp;
        input = SoundIn.ar(bus.round(1));
        amp = Amplitude.kr(input, 0.05, 0.05);
        # freq, hasFreq = Pitch.kr(input, ampThreshold: 0.0, median: 7);
        PitchShift.ar(in, winSize, (freq/centerpitch).lag(lag), pitchDispertion, timeDispersion)
        *(amp*adjvol);
    }, "pitch shifter 3", [{|val| val.linexp(0.0,1,10,4000)}, {|val| val.linlin(0,1,1,8).round(1)},
        {|val| val.linexp(0.0,1,0.01,2.01)-0.01}, {|val| val.linexp(0.0,1,0.01,2.01)-0.01},
        {|val| val.linlin(0.0,1,0.01,15)}, {|val| val.linlin(0.0,1,0.01,3)}]],
    //counterpoint
    [\ctp1, {arg in, rate=1, pitchDispersion=0.0, timeDispersion=0.0001, lag=0.01,
        windowSize=0.02;
        var freq, hasFreq, latch1, latch2, latch3, input, maxDelay=12;
        input = in;
        #freq, hasFreq = Pitch.kr(input);
        latch1 = Latch.ar(freq, Impulse.kr(rate));
        latch2 = DelayL.kr(Latch.ar(freq, Impulse.kr(rate)), maxDelay, 1/rate);
        latch3 = (latch1.cpsmidi - (latch1.cpsmidi - latch2.cpsmidi)).midicps.min(20000).max(20);
        PitchShift.ar(input, windowSize, (latch1/latch3)[0].lag(lag), pitchDispersion, timeDispersion;)
        + (input/2);
    }, "counterpoint pitch shifter 1", [{|val| val.linlin(0.0,1,(1/12),10)},
        {|val| val.linexp(0.0,1,0.01,2.01)-0.01}, {|val| val.linexp(0.0,1,0.01,2.01)-0.01},
        {|val|val.linlin(0.0,1,0.01,15)}, {|val| val.linlin(0.0,1,0.01,3)}]],
    [\ctp2, {arg in, rate=1, pitchDispersion=0.0, timeDispersion=0.0001, lag=0.01,
        windowSize=0.02;
        var freq, hasFreq, latch1, latch2, latch3, input, maxDelay=12;
        input = in;
        #freq, hasFreq = Pitch.kr(input);
        latch1 = Latch.ar(freq, Impulse.kr(rate));
        latch2 = DelayL.kr(Latch.ar(freq, Impulse.kr(rate)), maxDelay, 1/rate);
        latch3 = (latch1.cpsmidi - (latch1.cpsmidi - latch2.cpsmidi)).midicps.min(20000).max(20);
        PitchShift.ar(input, windowSize, (latch1/latch3)[0].lag(lag), pitchDispersion, timeDispersion;);
    }, "counterpoint pitch shifter 2", [{|val| val.linlin(0.0,1,(1/12),10)},
        {|val| val.linexp(0.0,1,0.01,2.01)-0.01}, {|val| val.linexp(0.0,1,0.01,2.01)-0.01},
        {|val|val.linlin(0.0,1,0.01,15)},{|val| val.linlin(0.0,1,0.01,3)}]],
    //comb filter controlled with noise
    [\cbg, {arg in, decayTime=0.5, freq=10, lag=5.0; CombL.ar(in * (LFNoise0.ar(freq.lag(lag)) &gt; 0),
        0.2, 0.2, decayTime);
    }, "comb filter controlled with noise", [{|val| val.linlin(0.0,1,0.0,10)},
        {|val| val.linexp(0.0,1,1.0,1000)}, {|val| val.linlin(0.0,1,0.01,15)}]],
    //low pass filter
    [\lpf, {arg in, freq=20000, lag=0.1; LPF.ar(in, freq.lag(lag));}, "low pass filter with lag",
        [{|val| val.linexp(0.0,1,10,20000)}, {|val| val.linlin(0.0,1,0,30)}]],
    //high pass filter
    [\hpf, {arg in, freq=10, lag=0.1; HPF.ar(in, freq.lag(lag));}, "high pass filter with lag",
        [{|val| val.linexp(0.0,1,10,20000)}, {|val| val.linlin(0.0,1,0,30)}]],
    //8 chan EQ
    [\eq8, {arg in, freq1=30, freq2=80, freq3=200, freq4=500, freq5=1200, freq6=3500,
        freq7=10000, freq8=17000, gain1=1, gain2=0, gain3=0, gain4=0, gain5=0, gain6=0,
        gain7=0, gain8=0, q1=0.71, q2=1.10, q3=0.98, q4=0.71, q5=0.71, q6=0.71, q7=0.71,
        q8=0.71, on1=0, on2=1, on3=1, on4=1, on5=1, on6=1, on7=1, on8=0, lag=0.5,
        master=0, lagPass=0.1;
        var signal, input;
        input = in;
        signal = (on1.linlin(0,1,1,0).lag(lagPass)*input) + (on1.lag(lagPass)*
            ((gain1.linlin(0,1,1,0.0).lag(lagPass)*BHiPass.ar(input,freq1.lag(lag),1/q1.lag(lag)))+ (gain1.lag(lagPass)*BHiPass4.ar(input,freq1.lag(lag),1/q1.lag(lag)));));
        signal = (on2.linlin(0,1,1,0).lag(lagPass)*signal) + (on2.lag(lagPass)
            *BLowShelf.ar(signal,freq2.lag(lag),1/(q2/2).lag(lag),gain2.lag(lag)));
        signal = (on3.linlin(0,1,1,0).lag(lagPass)*signal) + (on3.lag(lagPass)
            *BPeakEQ.ar(signal,freq3.lag(lag),1/(q3).lag(lag),gain3.lag(lag)));
        signal = (on4.linlin(0,1,1,0).lag(lagPass)*signal) + (on4.lag(lagPass)
            *BPeakEQ.ar(signal,freq4.lag(lag),1/(q4).lag(lag),gain4.lag(lag)));
        signal = (on5.linlin(0,1,1,0).lag(lagPass)*signal) + (on5.lag(lagPass)
            *BPeakEQ.ar(signal,freq5.lag(lag),1/(q5).lag(lag),gain5.lag(lag)));
        signal = (on6.linlin(0,1,1,0).lag(lagPass)*signal) + (on6.lag(lagPass)
            *BPeakEQ.ar(signal,freq6.lag(lag),1/(q6).lag(lag),gain6.lag(lag)));
        signal = (on7.linlin(0,1,1,0).lag(lagPass)*signal) + (on7.lag(lagPass)
            *BHiShelf.ar(signal,freq7.lag(lag),1/(q7/2).lag(lag),gain7.lag(lag)));
        signal = (on8.linlin(0,1,1,0).lag(lagPass)*signal) + (on8.lag(lagPass)*
            ((gain8.linlin(0,1,1,0.0).lag(lagPass)*BLowPass.ar(input,freq8.lag(lag),1/q8.lag(lag)))+
                (gain8.lag(lagPass)*BLowPass4.ar(input,freq8.lag(lag),1/q8.lag(lag)));));
        signal * master.dbamp;
    }, "8 channel equalizer"],
    //digital distortions
    [\ds1, {arg in, drive=1, adjVol=1, lag=0.1; var lagdr; lagdr = drive.lag(lag);((in*lagdr).distort
        * (lagdr.sqrt/lagdr))*adjVol}, "distort: basic digital distrotion", [{|val| val.linlin(0.0,1,1,200)},
        {|val| val.linlin(0.0,1,0.2,2.0).round(0.01)-0.01}, {|val| val.linlin(0.0,1,0.01,15)}]],
    [\ds2, {arg in, drive=1, adjVol=1, lag=0.1; var lagdr; lagdr = drive.lag(lag);((in*lagdr).softclip
        * (lagdr.sqrt/lagdr))*adjVol}, "softclip: basic digital distrotion", [{|val| val.linlin(0.0,1,1,200)},
        {|val| val.linlin(0.0,1,0.2,2.0).round(0.01)-0.01}, {|val| val.linlin(0.0,1,0.01,15)}]],
    [\ds3, {arg in, drive=1, adjVol=1, lag=0.1; var lagdr; lagdr = drive.lag(lag);((in*lagdr).clip2(1)
        * (lagdr.sqrt/lagdr))*adjVol}, "clip2: basic digital distrotion", [{|val| val.linlin(0.0,1,1,200)},
        {|val| val.linlin(0.0,1,0.2,2.0).round(0.01)-0.01}, {|val| val.linlin(0.0,1,0.01,15)}]],
    [\ds4, {arg in, drive=1, adjVol=1, lag=0.1; var lagdr; lagdr = drive.lag(lag);((in*lagdr).fold2(1)
        * (lagdr.sqrt/lagdr))*adjVol}, "fold2: basic digital distrotion", [{|val| val.linlin(0.0,1,1,200)},
        {|val| val.linlin(0.0,1,0.2,2.0).round(0.01)-0.01}, {|val| val.linlin(0.0,1,0.01,15)}]],
    [\ds5, {arg in, drive=1, adjVol=1, lag=0.1; var lagdr; lagdr = drive.lag(lag);((in*lagdr).wrap2(1)
        * (lagdr.sqrt/lagdr))*adjVol}, "wrap2: basic digital distrotion", [{|val| val.linlin(0.0,1,1,200)},
        {|val| val.linlin(0.0,1,0.2,2.0).round(0.01)-0.01}, {|val| val.linlin(0.0,1,0.01,15)}]],
    //reverb
    [\rvb, {arg in, mix=0, room=0, damp=0.0, lag=0.0, adjVol=1; FreeVerb.ar(in, mix.lag(lag),
        room.lag(lag), damp.lag(lag))*adjVol
    }, "Blackrain's FreeVerb", [{|val| val},{|val| val}, {|val| val}, {|val| val.linlin(0.0,1,0.01,15)},
        {|val| val.linlin(0.0,1,0.2,2.0).round(0.01)-0.01}]],
    [\gvb, {arg in, roomsize = 10, revtime = 3, damping = 0.5, inputbw =  0.5, spread = 15,
        drylevel = 1, earlyreflevel = 0.7, taillevel = 0.5, maxroomsize = 300, mul = 1, add = 0;
        GVerb.ar(in, roomsize, revtime, damping, inputbw, spread, drylevel, earlyreflevel,
            taillevel, maxroomsize, mul, add);
    }, "gverb"],
    //amplitude
    [\amp, {arg in, bus=0, adjVol=1, lag=0.1;
        (in*Amplitude.kr(SoundIn.ar(bus.round(1))).lag(lag))*adjVol
    }, "Amplitude Env Follower", [{|val| val.linlin(0,1,1,8).round(1)},
        {|val| val.linlin(0.0,1,1,30.0).round(0.01)-0.01}, {|val| val.linlin(0.0,1,0,10)} ]],
    //delay line with decay - linear interpolation - 12 secs max delay
    [\dl1, {arg in, delayTime=0, decayTime=1;CombL.ar(in,12,delayTime,decayTime);
    }, "delay with decay (linear)", [{|val| val.linlin(0.0,1,0,12.0)}, {|val| val.linlin(0,1,0,24.0)}]],
    [\dl2, {arg in, mul=1, freq=0.25, lag=0.1, decayTime=0, lag2=1;
        CombL.ar(in,12,LFNoise1.kr(freq.lag(lag), 1*(mul.lag(lag2)/2),
            0+(mul.lag(lag2)/2)).lag(lag),decayTime);
    }, "delay with decay (linear)", [{|val| val.linlin(0.0,1,0,12.0)}, {|val| val.linexp(0.0,1,0.25,20.0)},
        {|val| val.linlin(0.0,1,0.01,15)}, {|val| val.linlin(0,1,0,24.0)}]],
    //simple convolution 1
    [\cv1, {arg in, mix=0, bus=0, frameSize=1024, adjVol=1;
        var signal, input;
        input = in;
        signal = SoundIn.ar(bus.round(1));(Convolution.ar(input,signal,frameSize,adjVol*0.15)*mix)
        +(input*mix.linlin(0,1,1,0))}, "Simple Convolution 1", [{|val| val}, {|val| val.linlin(0,1,1,8).round(1)},
        {|val| [2, 4, 8, 16, 32 ,64, 128, 256,512,1024, 2048, 4096, 8192][val.linlin(0,1,0,12).round]},
        {|val| val.linlin(0.0,1,1,30.0).round(0.01)-0.01}]],
    [\cv2, {arg in, mix=0, bus=0, frameSize=1024, adjVol=1;
        var signal, input;
        input = in;
        signal = SoundIn.ar(bus.round(1));(Convolution.ar(signal,input,frameSize,adjVol*0.15)*mix)
        +(input*mix.linlin(0,1,1,0))}, "Simple Convolution 2", [{|val| val}, {|val| val.linlin(0,1,1,8).round(1)},
        {|val| [2, 4, 8, 16, 32 ,64, 128, 256,512,1024, 2048, 4096, 8192][val.linlin(0,1,0,12).round]},
        {|val| val.linlin(0.0,1,1,30.0).round(0.01)-0.01}]],
    [\lcv1, {arg in, mix=0, buffer=1, rate=1, frameSize=1024, adjVol=1;
        var signal, input;
        input = in;
        signal = PlayBuf.ar(1,buffer.round(1), rate, loop:1);
        (Convolution.ar(signal,input,frameSize,adjVol*0.15)*mix)+(input*mix.linlin(0,1,1,0));
    }, "Loop Convolution 1 - takes a buffer as in", [{|val| val}, {|val| val.linlin(0,1,1,8).round(1)},
        {|val| val.linlin(0,1,0.25,4)}, {|val| [2, 4, 8, 16, 32 ,64, 128, 256,512,1024, 2048, 4096, 8192]
            [val.linlin(0,1,0,12).round]}, {|val| val.linlin(0.0,1,1,30.0).round(0.01)-0.01}]],
    [\lcv2, {arg in, mix=0, buffer=1, rate=1, frameSize=1024, adjVol=1;
        var signal, input;
        input = in;
        signal = PlayBuf.ar(1,buffer.round(1), rate, loop:1);
        (Convolution.ar(input,signal,frameSize,adjVol*0.15)*mix)+(input*mix.linlin(0,1,1,0))},
    "Loop Convolution 2 - takes a buffer as in", [{|val| val}, {|val| val.linlin(0,1,1,8).round(1)},
        {|val| val.linlin(0,1,0.25,4)}, {|val| [2, 4, 8, 16, 32 ,64, 128, 256,512,1024, 2048, 4096, 8192]
            [val.linlin(0,1,0,12).round]}, {|val| val.linlin(0.0,1,1,30.0).round(0.01)-0.01}]],
    //multiply magnitudes of 2 spectrums
    [\mmp, {arg in, mix=0, bus=0, adjVol=1, frameSize=2048;
        var inA, chainA, chainB, chain, input;
        input = in;
        inA = SoundIn.ar(bus.round(1));
        chainA = FFT(LocalBuf(frameSize), input);
        chainB = FFT(LocalBuf(frameSize), inA);
        chain = PV_MagMul(chainA, chainB);
        adjVol * ((IFFT(chain)*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));
    }, "MagMul multiplies the magnitudes from two spectra",
    [{|val| val}, {|val| val.linlin(0,1,1,8).round(1)}]],
    //FFT freeze
    [\frz, {arg in, freeze=0, adjVol=1, frameSize=2048;
        var chain;
        chain = FFT(LocalBuf(frameSize), in);
        chain = PV_MagFreeze(chain, freeze);
        adjVol * IFFT(chain);}, "fft spectrum freeze",
    [{|val| val.round(1)}, {|val| val.linlin(0,1,1,4)}]],
    //FFT magnitude thresh
    [\mga, {arg in, thresh=0, adjVol=1, frameSize=2048;
        var chain;
        chain = FFT(LocalBuf(frameSize), in);
        chain = PV_MagAbove(chain, thresh);
        adjVol * IFFT(chain);}, "fft magnitude above threshold",
    [{|val| val.linexp(0.0,1,0.01,50.01)-0.01}, {|val| val.linlin(0,1,1,4)}]
    ],
    [\srt, {arg in, mix=0, adjVol=1;
        var chain, origmagsphases, magsphases, input;
        input = in;
        chain = FFT(LocalBuf(1024), input);
        origmagsphases = UnpackFFT(chain, 1024, 0, 250).clump(2).flop;
        magsphases = [origmagsphases[0][30..] ++ origmagsphases[0][..30],
            origmagsphases[1][30..] ++ origmagsphases[1][..30]];
        magsphases = magsphases.size.switch(
            1, {magsphases ++ origmagsphases[1]},
            2, {magsphases},
            {[magsphases, origmagsphases[1]]}
        );
        magsphases = magsphases.flop.flatten;
        chain = PackFFT(chain, 1024, magsphases, 0, 250, 0);
        adjVol * ((IFFT(chain)*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));
    }, "spectrum rotate", [{|val| val}, {|val| val.linlin(0,1,1,4)}]],
    [\sdf, {arg in, mix=0, adjVol=1;
        var chain, origmagsphases, magsphases, input;
        input = in;
        chain = FFT(LocalBuf(1024), input);
        origmagsphases = UnpackFFT(chain, 1024, 0, 250).clump(2).flop;
        magsphases = [origmagsphases[0].differentiate, origmagsphases[1].differentiate];
        magsphases = magsphases.size.switch(
            1, {magsphases ++ origmagsphases[1]},
            2, {magsphases},
            {[magsphases, origmagsphases[1]]}
        );
        magsphases = magsphases.flop.flatten;
        chain = PackFFT(chain, 1024, magsphases, 0, 250, 0);
        adjVol * ((IFFT(chain)*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));
    }, "spectrum differentiate", [{|val| val}, {|val| val.linlin(0,1,1,4)}]],
    [\srv, {arg in, mix=0, adjVol=1;
        var chain, origmagsphases, magsphases, input;
        input = in;
        chain = FFT(LocalBuf(1024), input);
        origmagsphases = UnpackFFT(chain, 1024, 0, 250).clump(2).flop;
        magsphases = [origmagsphases[0].reverse, origmagsphases[1].reverse];
        magsphases = magsphases.size.switch(
            1, {magsphases ++ origmagsphases[1]},
            2, {magsphases},
            {[magsphases, origmagsphases[1]]}
        );
        magsphases = magsphases.flop.flatten;
        chain = PackFFT(chain, 1024, magsphases, 0, 250, 0);
        adjVol * ((IFFT(chain)*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));
    }, "spectrum reverse", [{|val| val}, {|val| val.linlin(0,1,1,10)}]],
    [\ssq, {arg in, mix=0, adjVol=1;
        var chain, magsphases, input;
        input = in;
        chain = FFT(LocalBuf(1024), input);
        magsphases = UnpackFFT(chain, 1024);
        magsphases = magsphases.collect(_.sqrt);
        chain = PackFFT(chain, 1024, magsphases);
        adjVol * ((IFFT(chain)*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));
    }, "spectrum square root", [{|val| val}, {|val| val.linlin(0,1,1,4)}]],
    [\gate, {arg in, gates=1, adjVol=1; Gate.ar(in, gates.round(1))*adjVol}, "Gate with no envelope",
        [{|val| val.round}, {|val| val.linlin(0,1,1,10)}]
    ],
    [\lmt, {arg in, thresh=1, slopeAbove=1, slopeBelow=1, attack=0.0,
        release=0.02, preVol=1, postVol=1;
        Compander.ar(in*preVol, thresh: thresh, slopeBelow: slopeBelow, slopeAbove: slopeAbove,
            clampTime: attack, relaxTime: release)*postVol;
    }, "limiter", [{|val| val.linlin(0,1,0,-53).dbamp}, {|val| val.linlin(0,1,1,1/30)}]],
    [\cmp, {arg in, thresh=0, ratio=1, preVol=1, attack=0.01, release=0.02, slopeBelow=1,
        postVol=1;
        Compander.ar(in*preVol, thresh: thresh, slopeBelow: slopeBelow, slopeAbove: 1/ratio,
            clampTime: attack, relaxTime: release)*postVol;}, "compressor",
    [{|val| val.linlin(0,1,0,-53).dbamp}, {|val| val.linlin(0,1,1,30)}]
    ],
    [\lpc1, {arg in, mix=0, num=64, adjVol=1;
        var signal, input;
        input = in;
        signal = LPCError.ar(input, num);
        adjVol * ((signal*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));
    }, "lpc error", [{|val| val}, {|val| val.linlin(0,1,64,1)}]],
    [\fds1, {arg in, mix=0, alpha= -0.001, adjVol=1;
        var kernel, kernel2, signal, signal2, signal3, freq, hasFreq;
        signal = in;
        #freq, hasFreq = Pitch.kr(signal);
        kernel= WeaklyNonlinear.ar(signal,0,1,1,freq*2,0,0,alpha,3,0,0);
        kernel2= WeaklyNonlinear2.ar(signal,0,1,1,freq*2,0,0,alpha,3,0,0);
        signal2 = Convolution.ar(kernel+signal,kernel2, 2048, 0.0005)
        * Env.asr(0.01, 1.0, 0.01).kr(0,Amplitude.kr(signal));
        signal3 = Limiter.ar(signal2*adjVol);
        adjVol * ((signal3*mix.linlin(0,1,0,1))+(signal*mix.linlin(0,1,1,0)));}, "fede violence weakly",
    [{|val| val}, {|val| val.linlin(0,1,-0.1,0.1).round(0.001)}]
    ],
    [\fds2, {arg in, mix=0, num=64, adjVol=1;
        var kernel, signal, signal2, signal3, input;
        input = in;
        kernel = LPCError.ar(input, input.linlin(-1,1,num,1));
        signal = Convolution.ar(input,kernel, 2048);
        signal2 = LPCError.ar(signal, input.linlin(-1,1,1,num));
        signal3 = ((signal2+(input.clip2(0.05)*0.05))).clip2(1.0);
        adjVol * ((signal3*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));}, "fede lpc error",
    [{|val| val}, {|val| val.linlin(0,1,64,1)}]],
    [\vol, {arg in, gain1=0, gain2=0;
        in*gain1.dbamp*gain2.dbamp;}, "extra gain",
    [{|val| val.linlin(0,1,0,53)}, {|val| val.linlin(0,1,-53,0)}]
    ],
    [\rm1, {arg in, mix=0, freq=493.8833, sinamp=0.5, lagTime=10, adjVol=1;
        var signal, input;
        input = in;
        signal = input*SinOsc.ar(freq.lag(lagTime),0,sinamp);
        adjVol * ((signal*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));}, "ring modulation 1",
    [{|val| val}, {|val| val.linexp(0.0,1,10,20000.0)}, {|val| val}, {|val| val.linlin(0.0,1,0.0,10.0)},
        {|val| val.linlin(0.0,1,1,10.0).round(0.01)-0.01}]],
    [\rm2, {arg in, mix=0, sinamp=0.5, lagTime=0.1, adjVol=1;
        var signal, freq, hasFreq, input;
        input = in;
        # freq, hasFreq = Pitch.kr(input, ampThreshold: 0.0, median: 7);
        signal = input*SinOsc.ar(freq.lag(lagTime),0,sinamp);
        adjVol * ((signal*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));}, "ring modulation 1",
    [{|val| val}, {|val| val}, {|val| val.linlin(0.0,1,0.0,10.0)},
        {|val| val.linlin(0.0,1,1,10.0).round(0.01)-0.01}]],
    [\rm3, {arg in, mix=0, adjVol=1, sinamp=1.0, lagTime=0.1;
        var signal, freq, hasFreq, amp, input;
        input = in;
        # freq, hasFreq = Pitch.kr(input, ampThreshold: 0.0, median: 7);
        amp = Amplitude.kr(input, 0.05, 0.05);
        signal = input*SinOsc.ar(freq.lag(lagTime),0,sinamp*amp);
        adjVol * ((signal*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));}, "ring modulation 1",
    [{|val| val}, {|val| val.linlin(0.0,1,1,30.0).round(0.01)-0.01}, {|val| val},
        {|val| val.linlin(0.0,1,0.0,10.0)}]
    ],
    [\bpf, {arg in, vol=1, q=30, mix=1, lagTime=40;
        var signal, input, freq=622.25;
        input = in;
        signal = BPF.ar(input, freq, q.lag(lagTime))*q.lag(lagTime).linlin(0.01,30,10,1);
        vol.dbamp * ((signal*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)));}, "fixed band pass",
    [{|val| val.linlin(0,1,-53,0)}, {|val| val.linexp(0.0,1,0.01,30.0)},
        {|val| val}, {|val| val.linlin(0.0,1,0.0,10.0)}]
    ],
    [\chr1, {arg in, mix=0, depth=0.1, predelay=0.08, speed=0.05, ph_diff=0.5, lagTime=0.1;
        var soundin, input, sig, modulators, numDelays = 12;
        soundin = in;
        input = soundin * numDelays.reciprocal;
        modulators = Array.fill(numDelays, {arg i;
            LFPar.kr(speed * rrand(0.94, 1.06), ph_diff * i, depth.lag(lagTime),
                predelay.lag(lagTime));});
        sig = DelayC.ar(input, 2.0, modulators);
        sig = sig.sum;
        sig = sig * 3;
        ((sig*mix.linlin(0,1,0,1))+(soundin*mix.linlin(0,1,1,0)))
    }, "chorus 1", [{|val| val}, {|val| val.linlin(0.0,1,0,2)}, {|val| val.linlin(0.0,1,0,2.0)},
        {|val| val.linexp(0.0,1,0.01,10.0)}, {|val| val.linlin(0.0,1,0,6.2831)},
        {|val| val.linlin(0.0,1,0.0,10.0)}]],
    [\chr2, {arg in, mix=0, depth=0.1, predelay=0.08, speed=0.05, ph_diff=0.5, lagTime=0.1;
        var input, sig, soundin, modulators, numDelays = 24;
        soundin = in;
        input = soundin * numDelays.reciprocal;
        modulators = Array.fill(numDelays, {arg i;
            LFPar.kr(speed * rrand(0.94, 1.06), ph_diff * i, depth.lag(lagTime),
                predelay.lag(lagTime));});
        sig = DelayC.ar(input, 7.0, modulators);
        sig = sig.sum;
        sig = sig * 3;
        ((sig*mix.linlin(0,1,0,1))+(soundin*mix.linlin(0,1,1,0)))
    }, "chorus 2", [{|val| val}, {|val| val.linlin(0.0,1,0,2)}, {|val| val.linlin(0.0,1,0,2.0)},
        {|val| val.linexp(0.0,1,0.01,10.0)}, {|val| val.linlin(0.0,1,0,6.2831)},
        {|val| val.linlin(0.0,1,0.0,10.0)}]],
    [\cut1, {arg in, freq=3, decayTime=0.025; var trig;
        trig = Decay.kr(Impulse.kr(freq), decayTime);
        Gate.ar(in, trig)}, "cut 1", [{|val| val.linexp(0.0,1,0.01,100.0)},
        {|val| val.linexp(0.0,1,0.0001,0.1)}]],
    [\cut2, {arg in, freq=3, decayTime=0.025; var trig;
        trig = Decay.kr(Dust.kr(freq), decayTime);
        Gate.ar(in, trig)}, "cut 2", [{|val| val.linexp(0.0,1,0.01,50.0)},
        {|val| val.linexp(0.0,1,0.0001,0.1)}]],
    [\gdy1, {arg in, mix=0, maxMul=1, ampdist=2, durDist=3, adParam=1, ddParam=1,
        ampScale=0.5, durScale=0.0, kNum=40, transp=1;
        var freq, hasFreq, amp, minFreq, sig, input;
        input = in;
        #freq, hasFreq = Pitch.kr(input, minFreq: 20, ampThreshold: 0.0, median: 7);
        amp = Amplitude.kr(input, 0.05, 0.05).lag(0.1);
        minFreq = ((freq[0] * transp).fold2(1000)).abs.max(20);
        sig = Gendy1.ar(ampdist.max(0).min(6), durDist, adParam, ddParam, minFreq,(minFreq*maxMul).min(1000),ampScale,durScale,50,kNum)*amp;
        ((sig*mix.linlin(0,1,0,1))+(input*mix.linlin(0,1,1,0)))
    }, "gendy 1", [{|val| val.linexp(0.0,1,0.01,50.0)}, {|val| val.linexp(0.0,1,0.0001,0.1)}]],
];

~fxNames = {~fxs.flop[0].do{|item, index| (item ++ " -&gt; " ++ ~fxs.flop[2][index]).postln}};

~getFx = {arg key; ~fxs.flop[1][~fxs.flop[0].indexOf(key);];};

~fxArgs = {arg filter='dl1';
    var index, result;
    index = ~fxs.flop[0].indexOf(filter);
    if(index.notNil, {
        result =
        (~fxs.flop[1][index]).argNames.cs
                .replace("SymbolArray", "").interpret;
        result.removeAt(0);
        result;
    }, {"filter not found".warn; nil});
};

~fxArg = {arg filter='dl1', filterArg=0;
    var filterArgument;
    filterArgument = ~fxArgs.(filter)[filterArg];
    if(filterArgument.notNil, {
        filterArgument
    }, {
        "filter argumnet not found".warn; nil;
    });
};

~setFxArg = {arg filter='dl1', filterArg=0, val=0, bool=true;
    var index, result;
    index = ~fxs.flop[0].indexOf(filter);
    if(index.notNil, {
        result = (~fxs.flop[3][index][filterArg]).(val);
        if(bool, {
            [~fxArg.(filter, filterArg), result].postln;
        });
        result
    }, {"filter not found".warn; nil});
};
//mixer code
~makeStrings = {arg num=3, numChan=2, target=\master, replicate=\bus;
    var key;
    key = "[";
    num.do{|item|
        key = key ++ (" Ndef.ar('" ++ replicate.asString ++ item ++ "', " ++ numChan ++ "),");
    };
    key = key.replaceAt("]", key.size-1);

    "Ndef('" ++ target.asString ++ "')[0] = {arg vol=1; " ++ key ++ ".sum * vol};";
};

~makeBuses = {arg num=3, numChan=2;
    var bus, key;
    if(Ndef.all.isEmpty, {
        Ndef.ar(\master, numChan);
    });
    ~makeStrings.(num, numChan, \master, \bus).postln.interpret;
};

~makeChans = {arg chanArr, numChan=2;
    ~channels = chanArr;
    chanArr.do{|item, index|
        ~makeStrings.(item, numChan, ("bus" ++ index).asSymbol, \chan).postln.interpret;
    };
};

~busKeys = {Ndef.all[\localhost].activeProxies.asArray.select{|item| item.asString.includesAll("bus") }};
~chanKeys = {Ndef.all[\localhost].activeProxies.asArray.select{|item| item.asString.includesAll("chan") }};

~swapPatch = {arg chan=0, bus=0;
    ~channels.do{|item, index| if(item.includes(chan), {item.remove(chan).postln}) };
    ~channels.do{|item, index| if(index == bus, {item.add(chan).postln}) };
    ~makeChans.(~channels);
    };
~activeInserts = [];
~insert = {arg key, slot, func;
    if(~activeInserts.cs.includesAll([key, slot].cs).not, {
    ~activeInserts = ~activeInserts.add([key, slot]);
    });
    ("Ndef(" ++ key.cs ++ ")[" ++ (slot.abs+1).cs ++ "] = 'filter'  -&gt; " ++ func.cs).postln.interpret;
};
~removeInsert = {arg key, slot;
    ("Ndef(" ++ key.cs ++ ").removeAt(" ++ (slot.abs+1).cs ++ ");").postln.interpret;
};
~getInsert = {arg key, slot;
    Ndef(key).objects[slot.abs+1];
};
~instertSet = {arg key=\bus0, slot=0, fxKey=\fds2, argIndex=0, argVal=0;
    var getArgs;
    getArgs = ~setFxArg.(fxKey,argIndex,argVal);
    ~getInsert.(key, slot).set(~fxArg.(fxKey, argIndex), getArgs);
};
)</pre>
<h2><a class='anchor' name='Example'>Example</a></h2>

<p>Now let's play!<pre class='code prettyprint lang-sc'>~makeBuses.(3);
~makeChans.([ [0,1], [2,3], [4,5] ]); //chan 1,2 to bus1, chans 3,4 to bus2, chan 5,6 to bus3

Ndef(\master).play; //play master channel

~busKeys.();
~chanKeys.();

Ndef.all[\localhost].fadeTime = 1; //set all fadeTimes in the server to 1

(
Ndef(\chan0, {arg pan= 0, vol=1; Pan2.ar(Ndef.ar(\sound1, 1), pan, vol) });
Ndef(\chan1, {arg pan= 0, vol=1; Pan2.ar(Ndef.ar(\sound2, 1), pan, vol) });
Ndef(\chan2, {arg pan= 0, vol=1; Pan2.ar(Ndef.ar(\sound3, 1), pan, vol) });
Ndef(\chan3, {arg pan= 0, vol=1; Pan2.ar(Ndef.ar(\sound4, 1), pan, vol) });
)

Ndef(\sound1, {Decay.ar(Impulse.ar(1), 0.1, WhiteNoise.ar)});

~insert.(\master, 10, {|in| Limiter.ar(in, 0.9, 0.1).softclip }); //look-ahead limiter for safety...

~insert.(\master, 10, {|in| Compander.ar(in, in, 0.9, 1, 30, 0.001, 0.01).softclip }); //or compander?

~synthDefs.do{|item| item.name.postln } //list synthdefs

( //da patterns
~arrp = Pbind(\instrument, \wavestack1, \degree, Pseq((0..7).scramble, inf), \dur, 0.2);
~kick = Pbind(\instrument, \eightoeightkick, \degree, Pseq([0,\rest,0,\rest], inf), \dur, 0.2, \amp, 0.4);
~snare = Pbind(\instrument, \handclapsmash, \degree, Pseq([\rest,\rest,\rest, 0], inf), \reltime, 0.5, \dur, 0.2);
~randBass = ((0..5) ++ Array.fill(5, \rest)).scramble;
~bass = Pbind(\instrument, \fatvelocitybass, \degree,  Pseq(~randBass, inf), \dur, 0.2, \amp, 0.3, \ctranspose, -24);
)

Ndef.dictFor(s).do(_.quant = 4.0); //quantize every bar

(
Pdef(\pat1, ~arrp);
Pdef(\pat2, ~snare);
Pdef(\pat3, ~kick);
Pdef(\pat4, ~bass);
)

(
Ndef(\sound1, Pdef(\pat1));
Ndef(\sound2, Pdef(\pat2));
Ndef(\sound3, Pdef(\pat3));
Ndef(\sound4, Pdef(\pat4));
)

Ndef.dictFor(s).do(_.quant = 1.0); //quantize every beat

Ndef(\bus0).xset(\vol, 0);
Ndef(\bus1).xset(\vol, 0);

Ndef(\bus1).xset(\vol, 1);
Ndef(\bus0).xset(\vol, 1);


~channels
~insert.(\bus0, 0, {|in| FreeVerb.ar(in, 0.2, 1) }); //verb for arp and snr


~fxNames.(); //lists all fxs

~insert.(\chan0, 0, ~getFx.(\chr1);); //chorus
~getInsert.(\chan0, 0).set(\mix, 0.2);

~fxArgs.(\chr1);
~instertSet.(\chan0, 0, \chr1, 0, 0.5); //effect, argNum, mapped val (0-1)

~instertSet.(\chan0, 0, \chr1, 1, 0.01); //effect, argNum, mapped val (0-1)
~instertSet.(\chan0, 0, \chr1, 1, 0.1); //effect, argNum, mapped val (0-1)

~insert.(\chan3, 0, ~getFx.(\ds2););
~getInsert.(\chan3, 0).set(\adjVol, 0.8);
~getInsert.(\chan3, 0).set(\drive, 28);

~insert.(\chan2, 0, ~getFx.(\fds2););
~getInsert.(\chan2, 0).set(\mix, 0.05);
~getInsert.(\chan2, 0).set(\num, 24);

Ndef.dictFor(s).do(_.quant = 4.0); //quantize every beat

Ndef(\sound1, 0); //get rid of arp
Ndef(\sound2, 0); //no snare
Ndef(\sound3, 0); //no kick
Ndef(\sound4, 0); //no bass

(
Ndef(\sound1, Pdef(\pat1));
Ndef(\sound2, Pdef(\pat2));
Ndef(\sound3, Pdef(\pat3));
Ndef(\sound4, Pdef(\pat4));
)

Ndef.dictFor(s).do(_.quant = 1.0);

~insert.(\bus1, 0, {|in| HPF.ar(in, LFNoise1.kr(4).range(200,10000)) });

~insert.(\bus1, 0, {|in| in*MouseX.kr(0,1); });

~swapPatch.(0,1); //channel, bus

~swapPatch.(0,0); //channel, bus

~channels

~makeChans.([ [0,1], [2,3], [4,5] ].scramble.postln);

~removeInsert.(\bus1, 0);
~removeInsert.(\bus0, 0);

Ndef.clear(2);</pre>
<div class='doclink'>helpfile source: <a href='file:///Users/federicoreuben/Library/Application Support/SuperCollider/Extensions/ComputerDotPlay/HelpSource/ComputerDotPlay/Code Examples/Mixing Things.schelp'>/Users/federicoreuben/Library/Application Support/SuperCollider/Extensions/ComputerDotPlay/HelpSource/ComputerDotPlay/Code Examples/Mixing Things.schelp</a><br>link::ComputerDotPlay/Code Examples/Mixing Things::<br>sc version: 3.8.0</div></div></body></html>